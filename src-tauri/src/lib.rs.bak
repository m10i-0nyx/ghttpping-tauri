use serde::{Deserialize, Serialize};
use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};
use std::time::{Duration, Instant};

#[derive(Debug, Serialize, Deserialize)]
pub struct NetworkAdapter {
    pub name: String,
    pub ip_addresses: Vec<String>,
    pub has_ipv4: bool,
    pub has_ipv6: bool,
    pub has_ipv4_global: bool,
    pub has_ipv6_global: bool,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct EnvironmentCheckResult {
    pub adapters: Vec<NetworkAdapter>,
    pub ipv4_connectivity: bool,
    pub ipv6_connectivity: bool,
    pub dns_resolution: bool,
    pub internet_available: bool,
    pub error_messages: Vec<String>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct HttpPingResult {
    pub url: String,
    pub ip_address: Option<String>,
    pub status_code: Option<u16>,
    pub response_time_ms: Option<u64>,
    pub success: bool,
    pub error_message: Option<String>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct DnsResolution {
    pub ipv4_addresses: Vec<String>,
    pub ipv6_addresses: Vec<String>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct HttpPingDualResult {
    pub url: String,
    pub dns_resolution: DnsResolution,
    pub ipv4: HttpPingResult,
    pub ipv6: HttpPingResult,
}

#[tauri::command]
async fn environment_check() -> Result<EnvironmentCheckResult, String> {
    let mut result = EnvironmentCheckResult {
        adapters: vec![],
        ipv4_connectivity: false,
        ipv6_connectivity: false,
        dns_resolution: false,
        internet_available: false,
        error_messages: vec![],
    };

    // ネットワークアダプタの取得
    match get_network_interfaces() {
        Ok(adapters) => {
            result.adapters = adapters;
        }
        Err(e) => {
            result
                .error_messages
                .push(format!("ネットワークアダプタの取得に失敗: {}", e));
        }
    }

    // IPv4接続確認
    match check_ipv4_connectivity().await {
        Ok(connected) => {
            result.ipv4_connectivity = connected;
        }
        Err(e) => {
            result
                .error_messages
                .push(format!("IPv4接続確認に失敗: {}", e));
        }
    }

    // IPv6接続確認
    match check_ipv6_connectivity().await {
        Ok(connected) => {
            result.ipv6_connectivity = connected;
        }
        Err(e) => {
            result
                .error_messages
                .push(format!("IPv6接続確認に失敗: {}", e));
        }
    }

    // DNS解決確認
    match check_dns_resolution().await {
        Ok(resolved) => {
            result.dns_resolution = resolved;
        }
        Err(e) => {
            result
                .error_messages
                .push(format!("DNS解決確認に失敗: {}", e));
        }
    }

    // インターネット接続判定
    result.internet_available = (result.ipv4_connectivity || result.ipv6_connectivity)
        && result.dns_resolution;

    Ok(result)
}

#[tauri::command]
async fn ping_http(
    url: String,
    ignore_tls_errors: bool,
) -> Result<HttpPingResult, String> {
    let start = Instant::now();

    // URLの検証
    let parsed_url = match reqwest::Url::parse(&url) {
        Ok(u) => u,
        Err(e) => {
            return Ok(HttpPingResult {
                url: url.clone(),
                ip_address: None,
                status_code: None,
                response_time_ms: None,
                success: false,
                error_message: Some(format!("無効なURL: {}", e)),
            });
        }
    };

    // HTTPクライアントの構築
    let client = if ignore_tls_errors {
        reqwest::Client::builder()
            .danger_accept_invalid_certs(true)
            .timeout(Duration::from_secs(30))
            .build()
    } else {
        reqwest::Client::builder()
            .timeout(Duration::from_secs(30))
            .build()
    };

    let client = match client {
        Ok(c) => c,
        Err(e) => {
            return Ok(HttpPingResult {
                url: url.clone(),
                ip_address: None,
                status_code: None,
                response_time_ms: None,
                success: false,
                error_message: Some(format!("HTTPクライアント作成失敗: {}", e)),
            });
        }
    };

    // HTTPリクエスト
    let response = match client.get(parsed_url.as_str()).send().await {
        Ok(resp) => resp,
        Err(e) => {
            let elapsed = start.elapsed().as_millis() as u64;
            return Ok(HttpPingResult {
                url: url.clone(),
                ip_address: None,
                status_code: None,
                response_time_ms: Some(elapsed),
                success: false,
                error_message: Some(format!("接続エラー: {}", e)),
            });
        }
    };

    let elapsed = start.elapsed().as_millis() as u64;
    let status_code = response.status().as_u16();
    let success = response.status().is_success();

    Ok(HttpPingResult {
        url: url.clone(),
        ip_address: None,
        status_code: Some(status_code),
        response_time_ms: Some(elapsed),
        success,
        error_message: if success {
            None
        } else {
            Some(format!("HTTPステータス: {}", status_code))
        },
    })
}

#[tauri::command]
async fn ping_http_dual(
    url: String,
    ignore_tls_errors: bool,
) -> Result<HttpPingDualResult, String> {
    // URLの検証
    let parsed_url = match reqwest::Url::parse(&url) {
        Ok(u) => u,
        Err(e) => {
            return Err(format!("無効なURL: {}", e));
        }
    };

    let host = match parsed_url.host_str() {
        Some(h) => h,
        None => return Err("URLからホスト名を抽出できません".to_string()),
    };

    // ステップ1: DNS名前解決 (IPv4とIPv6)
    let dns_result = resolve_dns(host).await;
    let ipv4_addresses = dns_result.ipv4_addresses.clone();
    let ipv6_addresses = dns_result.ipv6_addresses.clone();

    // ステップ2: IPv4アドレスへのHTTP接続
    let ipv4_result = if !ipv4_addresses.is_empty() {
        connect_to_ip_with_host(
            url.clone(),
            &ipv4_addresses[0],
            host,
            ignore_tls_errors,
            parsed_url.port(),
        )
        .await
    } else {
        HttpPingResult {
            url: url.clone(),
            ip_address: None,
            status_code: None,
            response_time_ms: None,
            success: false,
            error_message: Some("IPv4アドレスが見つかりません".to_string()),
        }
    };

    // ステップ3: IPv6アドレスへのHTTP接続
    let ipv6_result = if !ipv6_addresses.is_empty() {
        connect_to_ip_with_host(
            url.clone(),
            &ipv6_addresses[0],
            host,
            ignore_tls_errors,
            parsed_url.port(),
        )
        .await
    } else {
        HttpPingResult {
            url: url.clone(),
            ip_address: None,
            status_code: None,
            response_time_ms: None,
            success: false,
            error_message: Some("IPv6アドレスが見つかりません".to_string()),
        }
    };

    Ok(HttpPingDualResult {
        url,
        dns_resolution: dns_result,
        ipv4: ipv4_result,
        ipv6: ipv6_result,
    })
}

// DNS名前解決を実行（PowerShell Resolve-DnsName を使用・非ブロッキング）
async fn resolve_dns(host: &str) -> DnsResolution {
    use std::process::Command;

    let host = host.to_string();

    // ブロッキング処理をスレッドプール上で実行
    let result = tokio::task::spawn_blocking(move || {
        let mut ipv4_addresses = Vec::new();
        let mut ipv6_addresses = Vec::new();

        // PowerShell コマンドで DNS解決（A レコード）
        let ipv4_output = Command::new("powershell")
            .args(&[
                "-Command",
                &format!(
                    "Resolve-DnsName -Name '{}' -Type A -ErrorAction SilentlyContinue | Select-Object -ExpandProperty IPAddress",
                    host
                ),
            ])
            .output();

        if let Ok(output) = ipv4_output {
            if output.status.success() {
                let result = String::from_utf8_lossy(&output.stdout);
                for line in result.lines() {
                    let ip = line.trim();
                    if !ip.is_empty() {
                        ipv4_addresses.push(ip.to_string());
                    }
                }
            }
        }

        // PowerShell コマンドで DNS解決（AAAA レコード）
        let ipv6_output = Command::new("powershell")
            .args(&[
                "-Command",
                &format!(
                    "Resolve-DnsName -Name '{}' -Type AAAA -ErrorAction SilentlyContinue | Select-Object -ExpandProperty IPAddress",
                    host
                ),
            ])
            .output();

        if let Ok(output) = ipv6_output {
            if output.status.success() {
                let result = String::from_utf8_lossy(&output.stdout);
                for line in result.lines() {
                    let ip = line.trim();
                    if !ip.is_empty() {
                        ipv6_addresses.push(ip.to_string());
                    }
                }
            }
        }

        DnsResolution {
            ipv4_addresses,
            ipv6_addresses,
        }
    })
    .await;

    result.unwrap_or(DnsResolution {
        ipv4_addresses: Vec::new(),
        ipv6_addresses: Vec::new(),
    })
}

// 指定されたIPアドレスにHTTP接続（curl コマンドを使用）
async fn connect_to_ip_with_host(
    original_url: String,
    ip_address: &str,
    host: &str,
    ignore_tls_errors: bool,
    _port: Option<u16>,
) -> HttpPingResult {
    use std::process::Command;

    let start = Instant::now();

    // curl コマンドを構築
    // -H "Host: hostname" でホストヘッダーを指定
    // https://ip/ で IPアドレスで接続
    // curl は TLS ハンドシェイク時に Host ヘッダーの値をSNIとして送信

    let is_https = original_url.starts_with("https");
    let scheme = if is_https { "https" } else { "http" };
    let request_url = format!("{}://{}/", scheme, ip_address);

    let mut cmd_args = vec![
        "-s".to_string(),                    // サイレントモード
        "-o".to_string(),                    // 出力抑制
        "/dev/null".to_string(),
        "-w".to_string(),                    // ステータスコード取得
        "%{http_code}".to_string(),
        format!("-H Host: {}", host),        // Host ヘッダー（SNIに使用）
        format!("-m 30"),                    // タイムアウト30秒
    ];

    if ignore_tls_errors {
        cmd_args.push("-k".to_string());    // --insecure: 証明書検証をスキップ
    }

    cmd_args.push(request_url.clone());

    // curl コマンドを実行
    let output = Command::new("curl.exe")
        .args(&cmd_args)
        .output();

    let elapsed = start.elapsed().as_millis() as u64;

    match output {
        Ok(output) => {
            if output.status.success() {
                let status_code_str = String::from_utf8_lossy(&output.stdout);

                if let Ok(status_code) = status_code_str.trim().parse::<u16>() {
                    let success = status_code >= 200 && status_code < 300;
                    HttpPingResult {
                        url: original_url,
                        ip_address: Some(ip_address.to_string()),
                        status_code: Some(status_code),
                        response_time_ms: Some(elapsed),
                        success,
                        error_message: if success {
                            None
                        } else {
                            Some(format!("HTTPステータス: {}", status_code))
                        },
                    }
                } else {
                    HttpPingResult {
                        url: original_url,
                        ip_address: Some(ip_address.to_string()),
                        status_code: None,
                        response_time_ms: Some(elapsed),
                        success: false,
                        error_message: Some("ステータスコード解析失敗".to_string()),
                    }
                }
            } else {
                let error_msg = String::from_utf8_lossy(&output.stderr);
                HttpPingResult {
                    url: original_url,
                    ip_address: Some(ip_address.to_string()),
                    status_code: None,
                    response_time_ms: Some(elapsed),
                    success: false,
                    error_message: Some(format!("curl エラー: {}", error_msg)),
                }
            }
        }
        Err(e) => {
            HttpPingResult {
                url: original_url,
                ip_address: Some(ip_address.to_string()),
                status_code: None,
                response_time_ms: Some(elapsed),
                success: false,
                error_message: Some(format!("curl 実行失敗: {}", e)),
            }
        }
    }
}

fn get_network_interfaces() -> Result<Vec<NetworkAdapter>, String> {
    use std::process::Command;

    // HTTP接続先アドレスを構築
    let _socket_addr = format!("{}:{}", ip_address, port_num)
        .parse::<std::net::SocketAddr>();

    if _socket_addr.is_err() {
        return HttpPingResult {
            url: original_url,
            ip_address: Some(ip_address.to_string()),
            status_code: None,
            response_time_ms: None,
            success: false,
            error_message: Some("無効なアドレス形式".to_string()),
        };
    }

    // HTTP クライアントを使用
    let client = reqwest::Client::builder()
        .timeout(Duration::from_secs(30))
        .build();

    let client = match client {
        Ok(c) => c,
        Err(e) => {
            return HttpPingResult {
                url: original_url,
                ip_address: Some(ip_address.to_string()),
                status_code: None,
                response_time_ms: None,
                success: false,
                error_message: Some(format!("クライアント作成失敗: {}", e)),
            };
        }
    };

    // IPアドレスでURLを置き換え
    let ip_for_url = if ip_address.contains(':') {
        format!("[{}]", ip_address)
    } else {
        ip_address.to_string()
    };

    let request_url = format!("http://{}:{}", ip_for_url, port_num);

    let response = match client
        .get(&request_url)
        .header("Host", host)
        .header("User-Agent", "ghttpping-tauri/1.0")
        .send()
        .await
    {
        Ok(resp) => resp,
        Err(e) => {
            let elapsed = start.elapsed().as_millis() as u64;
            return HttpPingResult {
                url: original_url,
                ip_address: Some(ip_address.to_string()),
                status_code: None,
                response_time_ms: Some(elapsed),
                success: false,
                error_message: Some(format!("接続エラー: {}", e)),
            };
        }
    };

    let elapsed = start.elapsed().as_millis() as u64;
    let status_code = response.status().as_u16();
    let success = response.status().is_success();

    HttpPingResult {
        url: original_url,
        ip_address: Some(ip_address.to_string()),
        status_code: Some(status_code),
        response_time_ms: Some(elapsed),
        success,
        error_message: if success {
            None
        } else {
            Some(format!("HTTPステータス: {}", status_code))
        },
    }
}

// HTTPS接続（SNI対応）
async fn connect_https_with_sni(
    original_url: String,
    ip_address: &str,
    host: &str,
    ignore_tls_errors: bool,
    port: Option<u16>,
) -> HttpPingResult {
    use std::sync::Arc;
    use tokio::io::{AsyncReadExt, AsyncWriteExt};
    use tokio::net::TcpStream;

    let start = Instant::now();

    // ポート番号を決定
    let port_num = port.unwrap_or(443);

    // TCP接続
    let tcp_result = TcpStream::connect(format!("{}:{}", ip_address, port_num)).await;

    let tcp_stream = match tcp_result {
        Ok(stream) => stream,
        Err(e) => {
            let elapsed = start.elapsed().as_millis() as u64;
            return HttpPingResult {
                url: original_url,
                ip_address: Some(ip_address.to_string()),
                status_code: None,
                response_time_ms: Some(elapsed),
                success: false,
                error_message: Some(format!("TCP接続エラー: {}", e)),
            };
        }
    };

    // TLS設定を構築
    let config = if ignore_tls_errors {
        // 証明書検証をスキップ（自署証明書対応）
        let config = rustls::ClientConfig::builder()
            .dangerous()
            .with_custom_certificate_verifier(Arc::new(
                NoServerCertVerification,
            ))
            .with_no_client_auth();
        Arc::new(config)
    } else {
        // 通常のシステム証明書検証
        let mut root_certs = rustls::RootCertStore::empty();
        let native_certs = rustls_native_certs::load_native_certs();
        for cert in native_certs {
            let _ = root_certs.add(cert);
        }

        let config = rustls::ClientConfig::builder()
            .with_root_certificates(root_certs)
            .with_no_client_auth();
        Arc::new(config)
    };

    // ServerName を作成（SNIに使用）
    let server_name = match rustls::pki_types::ServerName::try_from(host) {
        Ok(name) => name.to_owned(),
        Err(_) => {
            let elapsed = start.elapsed().as_millis() as u64;
            return HttpPingResult {
                url: original_url,
                ip_address: Some(ip_address.to_string()),
                status_code: None,
                response_time_ms: Some(elapsed),
                success: false,
                error_message: Some("無効なホスト名".to_string()),
            };
        }
    };

    // TLS接続
    let tls_stream = match tokio_rustls::TlsConnector::from(config)
        .connect(server_name, tcp_stream)
        .await
    {
        Ok(stream) => stream,
        Err(e) => {
            let elapsed = start.elapsed().as_millis() as u64;
            return HttpPingResult {
                url: original_url,
                ip_address: Some(ip_address.to_string()),
                status_code: None,
                response_time_ms: Some(elapsed),
                success: false,
                error_message: Some(format!("TLS接続エラー: {}", e)),
            };
        }
    };

    // HTTP/1.1 リクエスト構築
    let http_request = format!(
        "GET / HTTP/1.1\r\nHost: {}\r\nUser-Agent: ghttpping-tauri/1.0\r\nConnection: close\r\n\r\n",
        host
    );

    // HTTPリクエストを送信してレスポンスを受信
    let response_result = send_http_request(tls_stream, &http_request).await;

    let elapsed = start.elapsed().as_millis() as u64;

    match response_result {
        Ok((status_code, success)) => {
            HttpPingResult {
                url: original_url,
                ip_address: Some(ip_address.to_string()),
                status_code: Some(status_code),
                response_time_ms: Some(elapsed),
                success,
                error_message: if success {
                    None
                } else {
                    Some(format!("HTTPステータス: {}", status_code))
                },
            }
        }
        Err(e) => {
            HttpPingResult {
                url: original_url,
                ip_address: Some(ip_address.to_string()),
                status_code: None,
                response_time_ms: Some(elapsed),
                success: false,
                error_message: Some(e),
            }
        }
    }
}

// カスタム証明書検証（すべてのサーバー証明書を受け入れ）
struct NoServerCertVerification;

impl rustls::client::danger::ServerCertVerifier for NoServerCertVerification {
    fn verify_server_cert(
        &self,
        _end_entity: &rustls::pki_types::CertificateDer<'_>,
        _intermediates: &[rustls::pki_types::CertificateDer<'_>],
        _server_name: &rustls::pki_types::ServerName<'_>,
        _ocsp_response: &[u8],
        _now: rustls::pki_types::UnixTime,
    ) -> Result<rustls::client::danger::ServerCertVerified, rustls::Error> {
        Ok(rustls::client::danger::ServerCertVerified::assertion())
    }

    fn verify_tls12_signature(
        &self,
        _message: &[u8],
        _cert: &rustls::pki_types::CertificateDer<'_>,
        _dss: &rustls::DigitallySignedStruct,
    ) -> Result<rustls::client::danger::HandshakeSignatureValid, rustls::Error> {
        Ok(rustls::client::danger::HandshakeSignatureValid::assertion())
    }

    fn verify_tls13_signature(
        &self,
        _message: &[u8],
        _cert: &rustls::pki_types::CertificateDer<'_>,
        _dss: &rustls::DigitallySignedStruct,
    ) -> Result<rustls::client::danger::HandshakeSignatureValid, rustls::Error> {
        Ok(rustls::client::danger::HandshakeSignatureValid::assertion())
    }

    fn supported_verify_schemes(&self) -> Vec<rustls::SignatureScheme> {
        vec![
            rustls::SignatureScheme::RSA_PKCS1_SHA256,
            rustls::SignatureScheme::RSA_PSS_RSAE_SHA256,
            rustls::SignatureScheme::ECDSA_NISTP256_SHA256,
            rustls::SignatureScheme::ED25519,
        ]
    }
}

// HTTP/1.1 リクエスト送信とレスポンス受信
async fn send_http_request<S: tokio::io::AsyncRead + tokio::io::AsyncWrite + Unpin>(
    mut stream: S,
    request: &str,
) -> Result<(u16, bool), String> {
    use tokio::io::{AsyncReadExt, AsyncWriteExt};

    // HTTPリクエスト送信
    stream
        .write_all(request.as_bytes())
        .await
        .map_err(|e| format!("リクエスト送信エラー: {}", e))?;

    // レスポンスヘッダー受信
    let mut buffer = vec![0; 4096];
    let n = stream
        .read(&mut buffer)
        .await
        .map_err(|e| format!("レスポンス受信エラー: {}", e))?;

    if n == 0 {
        return Err("レスポンスが空".to_string());
    }

    let response_str = String::from_utf8_lossy(&buffer[..n]);

    // HTTPステータスコード抽出
    if let Some(first_line) = response_str.lines().next() {
        if let Some(status_part) = first_line.split_whitespace().nth(1) {
            if let Ok(status_code) = status_part.parse::<u16>() {
                let success = status_code >= 200 && status_code < 300;
                return Ok((status_code, success));
            }
        }
    }

    Err("ステータスコード抽出失敗".to_string())
}

// ネットワークインターフェース情報を取得
fn get_network_interfaces() -> Result<Vec<NetworkAdapter>, String> {
    use std::process::Command;

    let output = Command::new("powershell")
        .args(&[
            "-Command",
            "Get-NetAdapter | Where-Object {$_.Status -eq 'Up'} | Select-Object -ExpandProperty Name",
        ])
        .output()
        .map_err(|e| format!("PowerShellコマンド実行失敗: {}", e))?;

    if !output.status.success() {
        return Err("ネットワークアダプタの取得に失敗しました".to_string());
    }

    let adapter_names = String::from_utf8_lossy(&output.stdout);
    let mut adapters = Vec::new();

    for name in adapter_names.lines() {
        let name = name.trim();
        if name.is_empty() {
            continue;
        }

        // 各アダプタのIPアドレスを取得
        let ip_output = Command::new("powershell")
            .args(&[
                "-Command",
                &format!(
                    "Get-NetIPAddress -InterfaceAlias '{}' | Select-Object -ExpandProperty IPAddress",
                    name
                ),
            ])
            .output();

        if let Ok(ip_out) = ip_output {
            let ip_addresses: Vec<String> = String::from_utf8_lossy(&ip_out.stdout)
                .lines()
                .map(|s| s.trim().to_string())
                .filter(|s| !s.is_empty())
                .collect();

            let mut has_ipv4 = false;
            let mut has_ipv6 = false;
            let mut has_ipv4_global = false;
            let mut has_ipv6_global = false;

            for ip_str in &ip_addresses {
                if let Ok(ip) = ip_str.parse::<IpAddr>() {
                    match ip {
                        IpAddr::V4(v4) => {
                            has_ipv4 = true;
                            if is_global_ipv4(&v4) {
                                has_ipv4_global = true;
                            }
                        }
                        IpAddr::V6(v6) => {
                            has_ipv6 = true;
                            if is_global_ipv6(&v6) {
                                has_ipv6_global = true;
                            }
                        }
                    }
                }
            }

            adapters.push(NetworkAdapter {
                name: name.to_string(),
                ip_addresses,
                has_ipv4,
                has_ipv6,
                has_ipv4_global,
                has_ipv6_global,
            });
        }
    }

    Ok(adapters)
}

// IPv4がグローバルアドレスかどうかを判定
fn is_global_ipv4(ip: &Ipv4Addr) -> bool {
    !ip.is_private()
        && !ip.is_loopback()
        && !ip.is_link_local()
        && !ip.is_broadcast()
        && !ip.is_multicast()
        && !ip.is_unspecified()
}

// IPv6がグローバルアドレスかどうかを判定
fn is_global_ipv6(ip: &Ipv6Addr) -> bool {
    !ip.is_loopback() && !ip.is_multicast() && !ip.is_unspecified()
}

// IPv4接続確認
async fn check_ipv4_connectivity() -> Result<bool, String> {
    let client = reqwest::Client::builder()
        .timeout(Duration::from_secs(10))
        .build()
        .map_err(|e| format!("クライアント作成失敗: {}", e))?;

    match client.get("https://getipv4.0nyx.net/").send().await {
        Ok(response) => Ok(response.status().is_success()),
        Err(_) => Ok(false),
    }
}

// IPv6接続確認
async fn check_ipv6_connectivity() -> Result<bool, String> {
    let client = reqwest::Client::builder()
        .timeout(Duration::from_secs(10))
        .build()
        .map_err(|e| format!("クライアント作成失敗: {}", e))?;

    match client.get("https://getipv6.0nyx.net/").send().await {
        Ok(response) => Ok(response.status().is_success()),
        Err(_) => Ok(false),
    }
}

// DNS解決確認
async fn check_dns_resolution() -> Result<bool, String> {
    use tokio::net::lookup_host;

    match lookup_host("example.com:80").await {
        Ok(mut addrs) => Ok(addrs.next().is_some()),
        Err(_) => Ok(false),
    }
}

#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    tauri::Builder::default()
        .plugin(tauri_plugin_shell::init())
        .invoke_handler(tauri::generate_handler![environment_check, ping_http, ping_http_dual])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
